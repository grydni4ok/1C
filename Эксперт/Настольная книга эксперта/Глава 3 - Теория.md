# КАК ИЗМЕРЯТЬ И ПОЛУЧАТЬ ЦИФРЫ

Получить длительность ключевых операций и оценок по шкале APDEX - встроить подсистему "Оценка производительности" из состава БСП.
Ошибки блокировок, системные ошибки, ошибки защиты по ТЖ. Этот алгоритм планируется встаривать в Центр контроля качества (ЦКК).
Аварийные завершения процессов, можно считать по дампам, образующимися при авдении процессов при включенной специальной настройке. Рекомендуется использовать ЦКК, в него уже всьтроен подсчет дампов и их группировка по офсетам.
Зависание кластера нужно отслеживать с помощью ЦКК.

1.	 Получить список жалоб.
2.	 По списку жалоб составить список ключевых операций (ограниченное количество - 20 самый максимум).
3.	 По списку ключевых операций совместно с заказчиком назначить целевое время
и приоритеты.
4.	 Пока идет согласование по п. 3 (это не всегда быстро), можно подключить
и настроить ЦУП, но он не понадобится до этапа 8.
5.	 По списку ключевых операций встроить замеры в базу, получить результаты.
6.	 Сравнить результаты с целевым временем. Операции с плохим фактическим
временем относительно целевого (с плохим APDEX) следует начинать разбирать
в порядке убывания приоритета.
7.	 По каждой операции найти наиболее типичное действие (по гистограмме найти
интервал времени, в который попало наибольшее количество замеров).
8.	 Для этого действия провести анализ, выяснить, что это за действие (как –
описано в этом разделе ниже).
9.	 Понять, с какой проблемой имеем дело, что придется делать, и оценить трудоемкость решения.
10.	 Оформить результаты по п. 7 и 8 в виде отчета, согласовать с заказчиком дальнейшие действия.
11.	 Воплотить рекомендации в жизнь, сравнить результаты с целевым временем.

У проблем производительности есть два обычных подозреваемых:
■ плохая работа запроса,
■ плохая работа кода


--------------------------------------------------------------------------------------------------------------------------------------
## ГЛАВА 3 ТЕОРИЯ

**Ключевая операция (КО)** - это операция (действие) системы, у которой количесвенной характеристикой, определяющей наступление нежелательного состояния, является время выполнения этой оперции, и наступление этого нежелательного состояния является важной проблемой.
Ключевые операции:
  - Всегда начинаются на клиенте
  - Не может состоять из нескольких интерактиных дейсвтвий пользователя, потому что мы оптимизируем систему, а не работу пользователей
  - Ключевая операция всегода заканчивается на клиенте. Мы не можем разбить на несколько КО дейсвие, которое является единым с точки зрения пользователя.

Перечень ключевых операций (нужно заполнить список вместе с клиентом)  
Ключевая операция | Приоритет | Целевое время Т (сек.)  
                  |          |   
                  |          |  
                  |          |  
Перечень ключевых операций является предварительным и может быть изменен по взаимному согласию сторон.
Целевое время, указанное для каждой ключевой операции, также может уточняться в процессе выполнения работ по договору при наличии объективных причин, например, при несовпадении субъективной оценки пользователей и оценки APDEX.


--------------------------------------------------------------------------------------------------------------------------------------
## 3.2. Методика APDEX

Для вычисления APDEX, необходимо обработать данные по времени выполнения всех ключевых операций и получить следующие значения:
N – общее количество выполнений данной операции
NS – количество выполнений с временем отклика от 0 до Т
NT – количество выполнений с временем отклика от T до 4T
Значение APDEX вычисляется по формуле: APDEX = (NS + NT/2)/N

![Шкала APDEX](https://github.com/grydni4ok/1C/blob/main/%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82/%D0%9D%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0%20%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82%D0%B0/%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/APDEX.png)

Существует обратная задача – получить целевое время по заданному значению APDEX, если заказчик затрудняется это целевое время назвать.
В системе ОП (оценка производительности) встроен механизм автоматического подбора времени Т под заданное значение APDEX.
Если нудно ручное решение см стр 29.

--------------------------------------------------------------------------------------------------------------------------------------
## Критичные ошибки

Критичные ошибки:
  - Ошибки блокировок
  - системные ошибки
  - ошибки защиты
  - аварийные процессы завершения процессов кластера серверов 1С:Предприятия
  - зависание процессов кластера серверов 1С:Предприятия

**Ошибка блокировок** - называюется ошибка, возникающая при превышении времени ожидания на блокировке (lock request time out) или неразрешимый конфликт блокировок (взаимоблокировка - deadlock).

**Системные ошибка** - ошибка данных информационной базы или ошибка платформы, которая не позволяет пользователю выполнить какое-либо прикладное действие с системой. Любые фукнциональные ошибки кода конфигурации не являются системными ошибками.

**Аварийные завершения процессора кластеров серверов**. Падением кластера серверов 1С:Предприятия называется самопроизвольная выгрузка любого процесса кластера серверов или всех его процессов одновременнно.

**Зависание процессов кластера серверов** - состояние кластера, при котором он не отвечает на запросы пользователей, не позволяет создавать новое клиентское подключение и т.п., но при этом остается загруженным в память рабочего сервера.

--------------------------------------------------------------------------------------------------------------------------------------
## Расчет доступности системы

## Регламентные работы


--------------------------------------------------------------------------------------------------------------------------------------
## 3.6.Транзакции

При выполнении 2х транзакций, не происходит (как правило) полной изоляции одной транзакции от другой. Такое возможно, но это снижает паралельность работы и может приводит к блокировкам.

Проблемы возникающие при взаимодействии 2х транзакций:
  - **потерянное обновление (lost update)** - если один и тот же блок данных (запись + запись) одновременно изменяют 2 разные транзакции, то будет зафиксированно только одно изменение, второе потеряется (при работе 1С не возможно, поскольку не бывает записи вне транзакций);
  - **грязное чтение (dirty read)** - чтение данных, добавленных или измененных транзакцией (запись + чтение), может дать неточный результат, потому что та тарнзакция в последствии может не подтвердится.
  - **не повторяющееся чтение (non-repeatable read)** - при повторном чтении в рамках одной транзакции оказывается, что ранее прочитанные данные изменены или удалены.
  - **фантомное чтение (phantom read)** - при поторном чтении в рамках одной и той же транезакции, оказывается что прочитанны строки, которых при предыдущем чтении не было (новые строки называются "фантомами").


Уровни изоляции для СУБД:
  - **Read Uncommited** - (неподтвержденное чтение, изоляций незафиксированного чтения) самый низкий уровень изоляции, указывает, что запросы могут считывать строки, которые были изменены еще не зафиксированными транзакциями. Допускается чтение незафиксированных изменений текущей транзакцией (параллельными транзакциями) и незафиксированных изменений параллельных транзакций (нашей и другими тразакциями). Возможны грязные, неповторяемые чтения и фантомы.
  - **Read Committed Snapshot (Версионники)** - (подтвержденное чтение с включенным параметром READ_COMMITTED_SNAPSHOT).
    Для СУБД MS SQL в 1С поддерживается начиная с версии 8.3 (В 8.2 можно установить свойство READ_COMMITTED_SNAPSHOT настройках, но оно будет каждый раз сбрасываться при реструктаризации).
    В СУБД ORACLE уровень с такими же свойствами используется 1С и в версии 8.2.
    Уровень указывает, что запросы не могут считывать данные, которые были изменены другими транзакциями, но еще не были зафиксированы.
    В момент начала чтения транзакции будет выделен моментальный снимок (snapshot) базы данных, включающий в себя все изменения завершенных к этому моменту времени транзакций. Транзакция может читать этот снимок, получая чистые данные (без «грязного» чтения) и при этом никого не блокируя.
    «Грязные» чтения невозможны, возможны неповторяемые чтения и фантомы.
  - **Read Committed** - (подтвержденное чтение, изоляция зафиксированного чтения).
    Как и уровень Read Committed Snapshot, указывает, что запросы не могут считывать данные, которые были изменены другими транзакциями, но еще не были зафиксированы.
    Привыполненииоперацийчтения текущейтранзакциейиспользуются разделяемые блокировки для предотвращения изменения строк другими транзакциями (время освобождения в общем зависит от того, что блокируется – строка, страница или таблица, но достаточно понимать, что все освобождается после выполнения запроса) и для предотвращения от считывания строк, измененных другими транзакциями, пока они не завершатся. «Грязные» чтения невозможны, возможны неповторяемые чтения и фантомы.

    **Примеры Read Committed**
    
    Мы в транзакциях открываем 2 формы списка модально (нельзя открывать модально, тем более в транзакции).
    
    ![Код для открываемых форм списка](https://github.com/grydni4ok/1C/blob/main/%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82/%D0%9D%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0%20%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82%D0%B0/%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/%D0%93%D1%80%D1%8F%D0%B7%D0%BD%D0%BE%D0%B5%D0%A7%D1%82%D0%B5%D0%BD%D0%B8%D0%B5(%D0%91%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8)0.png)
    
    Слева, в открытых списках в открытой транзакции, мы поменяли и записали 2 выделенных объекта. Т.к. транзакция все еще открыта и не зафиксирована, измененые данные являются "грязными". Справа мы пытамся прочитать эти данные, обновив форму списка. Данные начинают считываться сверху вниз, устанавливая для каждой записи блокировку (S Shared), дойдя до измененой записи, мы не сможем установить блокировку, т.к. на этой записи уже стоит другая блокировка (X eXclusive - исключительная блокировка).
    
     ![Считывание форм списка с установленными блокировками](https://github.com/grydni4ok/1C/blob/main/%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82/%D0%9D%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0%20%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82%D0%B0/%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/%D0%93%D1%80%D1%8F%D0%B7%D0%BD%D0%BE%D0%B5%D0%A7%D1%82%D0%B5%D0%BD%D0%B8%D0%B5(%D0%91%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8)1.png)
    
    При обращении к заблокированных данным, возникает ожидание. Если открытая транзакция успеет завершиться к моменту пока идет ожидание, обновление списка выполнится. В противном случае возникнет конфликт блокировок для MS SQL Server.
    
    ![Конфликт блокировок для MS SQL Server](https://github.com/grydni4ok/1C/blob/main/%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82/%D0%9D%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0%20%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82%D0%B0/%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/%D0%93%D1%80%D1%8F%D0%B7%D0%BD%D0%BE%D0%B5%D0%A7%D1%82%D0%B5%D0%BD%D0%B8%D0%B5(%D0%91%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA%D0%B8)2.png)

    **Возможное решение данной проблемы** - переходим на версию 8.3. Начиная с этой версии, в 1С поддерживается Read Committed Snapshot. Можно в теории установить в ручную, но при каждом обновлении 1С, эта "галка" будет сброшена в False.
    
    ![Read Committed Snapshot MS SQL Server](https://github.com/grydni4ok/1C/blob/main/%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82/%D0%9D%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0%20%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82%D0%B0/%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/Snapshot%20%D0%B2%20MS%20SQL.png)
     
  - **Repeatable read** - (повторяемое чтение, изоляция повторяемого чтения) **Только в режиме автоматичесих блокировок**.
    Указывает на то, что другие транзакции не могут изменять данные, читаемые текущей транзакцией, до ее завершения.
    Как и предыдущий уровень, указывает что запросы не могут считывать данные, которые были изменены другими транзакциями, но еще не были зафиксированны.
    Разделяемые блокировки применяются ко всем данным, считываемым любым запросом транзакцией, и сохранются до конца ее завершения. Это запрещает другим транзакциям изменять строки, считываемые текущей транзакцией.

  - **Serializable** - (упорядоченный, изоляция упорядочиваемых транзакций, сериализуемый, упорядоченные транзакции, сериализуемые транзакции) **Только в режиме автоматичесих блокировок**.
    Отличие от Repeatable read в том, что другие транзакции не могут вставлять новые стоки со значениями ключа, которые входят в диапозон ключей, счтываемыми запросами текущей транзакции, до ее завершения.
    Остальные ограничения сохраняются.


--------------------------------------------------------------------------------------------------------------------------------------
## 3.7.Блокировки данных СУБД. Уровни блокировок. Совместимость блокировок.

Блокировка - это отметка (информация) о том, что требуемый ресурс в настоящее время захвачен. Это не физический захват ресурса, а инфомация о том, что ресурс захвачен.
Уровни блокировок ресурсов:
  - **Shared (S)** (Разделяемая, совмещаемая блокировка) - используется для операций считывания, которые не меняют и не обновляют данные, такия как инструкция Select.
  - **Update (U)** (Блокировка обновления) - применятеся к тем ресурсам, которые могут быть обновлены. Предотвращая возникновения распространенной формы взаимоблокировки, возникающей тогда, когда несколько сеансов считвают, блокируют и затем, возможно обновляют ресурс.
  - **Exclusive (X)** (Эксклюзивная, исключительная, монопольная блокировка) - используется для операций модификации данных, таких как инструкция INSETR, UPDATE, DELETE. Гарантирует, что несколько обновлений не будет выполнено одновременно для одного ресурса.
  - **Intent (IS, IX, SIX)** (Блокировка с намерением) - Используется для создания иерархии блокировок. Типы намерения блокировки: с намерением совмещаемого доступа (IS), с намерением монопольного доступа (IX), с так же совмещаемая с намерением монопольного доступа (SIX).
  - **Schems (Sch-S, Sch-M)** (Блокировка схемы) - Используется во время выполнения опреции, зависящей от схемы таблицы. Типы Блокировки схем: блокировка изменения схемы (Sch-S), блокировка стабильности схемы (Sch-M).
  - **Bulk Update (BU)** (блокировка массового обновления) - используется, если выполняется массоввое копирование таблиц и указана подсказка TABLOCK.
  - **Key-range** (Диапозон ключей) - защищает диапозон строк, считываемый запросом при использовании уровня изоляции транзакции Serializable. Запрещает другим транзакциям вставлять строки, что помагает запросам такой транзакции уточнять, были ли запросы запущены повторно.

**Совместимость блокировок**

 ![Совместимость блокировок](https://github.com/grydni4ok/1C/blob/main/%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82/%D0%9D%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0%20%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82%D0%B0/%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/%D0%A1%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C%D0%91%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D0%BA.png)


--------------------------------------------------------------------------------------------------------------------------------------
## 3.8. Сведения о управляемых и объектных блокировках.

2 механизма блокировок:
 - Транзакционные;
 - Объектные.

**Транзакционные блокировки** - аналог блокировок СУБД. Они обеспечиваются менеджером транзакционных блокировок. Они используются в дополнение к блокировкам СУБД, чтобы убрать побочные эфекты параллелеизма, присущие уровню изоляции Read Commited, котрый устанавливается для СУБД при включении управляемого режима управления блокировкой данных в 1С (это не единственное их назначение, в целом область применения управляемых блокировок намного шире).

Маханизм **объектных блокировок** позволяет оповестить пользователей о захвате объектных данных: справочники, документы и т.д.
Возможные сообщения:
  1. Не удалось заблокировать запись. Действие (изменение, удаление, или блокировка записи) не выполнено.
  2. Операция не может быть выполнена из-за не соответствия версии или отсутствия записи базы данных (возможно, запись была изменена или удалена). / Данные были изменены или удалены другим пользователем.

Если один пользователь начинает модификацию объекта в форме, а другй после этого тоже попытается начать редактирование того же объекта, **он получит сообщение с ошибкой 1**. Расширение формы устанавливает **пессимистическую блокировку**, не позволяющую редактировать кем-то уже редактириумые данные.
Если теперь первый пользователь запишет изменения и закроет форму, то пессимистическая блокировка снимется. Но если другой пользователь опять попытается начать редактирование того же объекта в той же открытой ранее форме, **он получит сообщение 2** - сработает **оптимистическая блокировка**, не позволяющая редактироваить данные, измененные или удаленные за время, прошедшее с их считывания.

 Кроме того, пессимистическая объектная блокировка может быть установлена программно методом <Объект>.Заблокировать() и снята методом <Объект>.Разблокировать().

 Уровни транзакционных блокировок:
   - Резделяемый (Shared) - позволяет конкурирующему процессу установить разделяемую блокировку по этому же условю, но не позволит установить исключительную блокировку.
   - Исключительный (eXclusive) - исключительная блокировка не позволит конкурирующему процессу установить разделяемую или исключительную блокировку по этому же условию.

Совместимость уровней блокировок:
![Совместимость уровней блокировок](https://github.com/grydni4ok/1C/blob/main/%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82/%D0%9D%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0%20%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82%D0%B0/%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/%D0%A1%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C%20%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B9%20%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BE%D0%BA.png)


--------------------------------------------------------------------------------------------------------------------------------------
## 3.9. Ошибки блокировок: таймауты и взаимоблокировки.

Причины конфликтов блокировок:
  1. Транзакция стоит в очереди с точки зрения системы уже слишком долго, не выполняя действий и, возможно, блокируя ресурсы, котроые ей требовались на предыдущих шагах. Такая причина называется таймаутом, ошибкой превышения времени ожидания на блокировке.
  2. Прозошла ситуация, которая была квалифицирована как взаимная блокировка ресурсов (deadlock, взаимная блокировка).

Тексты ошибок:

![Тексты ошибок](https://github.com/grydni4ok/1C/blob/main/%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82/%D0%9D%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0%20%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82%D0%B0/%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/%D0%A2%D0%B5%D0%BA%D1%81%D1%82%D1%8B%D0%9E%D1%88%D0%B8%D0%B1%D0%BE%D0%BA.png)

**Таймаут**

Время, которое тарзакция может ждать освобождение ресурса, задается в свойствах системы. 

Причины таймаутов:
  - неправильная организация рабочего процесса (конкуренция за одни и те же данные);
  - выбор неправильного прикладного объекта метаданных конфигарации для хранения данных (тоже конкуренция за одни и те же данные);
  - игнорирование особенностей работы ресурсов, в которые возможна только последователльная запись;
  - не оптимальная работа запросов, как вызывающая избыточные блокировки, так и увеличивающая время выполнения самих этих запросов;
  - использование мехнизмов, процирующих не оптимальную работу запросов;
  - использование высокого уровня изоляции транзакций;
  - включение в транзакцию механизмов, вызывающих непрогнозируемое увеличение кк времени и ставящих ее в зависимость от посторонних ресурсов (модальные окна, работа с внешними источниками, влоденные транзакции);
  - увеличение времени транзакции, как за счет медленной работы кода, так и за счет объединения нескольких транзакций в одну (например, групповая обработка документов в одной транзакции).

**Взаимоблокировка**

Возникает, когда 2 или более транзакции ждут друг друга из-за того, что каждая из сторон блокирует ресурс, необходимый другой стороне.
В СУБД это воздейтсвие происходит так: при обнаружении взаимоблокировки монитор блокировок назначает жертву, производит откат ее транзакции и возвращает приложению ошибку. Остальные прилодения имеют возможность успешно завершиться.

Возникновения взаимоблокировок сводят к следующим ситуациям:
  1. Захват ресурсов в разном порядке X1 -> X2, X2-> X1. Частный случай X1 -> S12, X2 -> S12
  2. Повышение уровня блокировки ресурса S1 -> X1, S1-> X1.

Для устранения взаимоблокировк нужно придерживаться следующих правил:
  - осуществлять запись ресурсов в одинаковом порядке;
  - избегать чтение ресурса после его записи, если включен режим разделения итогов; либо этого нельзя избежать, на время записи устанавливать свойство *Блокировать для изменения* в Истину;
  - в режиме автоматического управления блокировками 1С в запросах включать опцию *Для изменения* на те ресурсы, которые потом будут записаны;
  - если есть необходимость поставить управляемую блокировку 1С перед чтением данных ресурса, в который потом будет идти запись, нужно ставить не разделяемую блокировку, а исключительную.

Далее, как и в случаях борьбы с таймутами, помогает следующее:
  - правильная организация рабочего процесса;
  - выбор более подходящго объекта метаданных конфигурации для хранения данных
  - правильная организация работы ресурсов, в которые возможна только последовательняа запись;
  - оптимизация запросов, ликвидация избыточных блокировок и уменьшение времени выполнения самих этих запросов;
  - отказ от использования механизмов, провоцирующих неотимальную работу запросов: это механизм разделения доступа на уровне записей при работе пользователя с ограниченными правами и механимз разделения данных при работе пользователя с незаданным общим реквизитом, если указано импользование разделяемых данных "независимо и совместно";
  - снижение уровня изоляции транзакций (т.е. переход с режима автоматического управления блокировками 1С на управляемый). Это с одной стороны, уменьшит блокирование избыточных данных (сниметсчя защита диапозона ключей), а с другой стороны, уменьшит время блокировки части ресурсов, т.к. все разделяемые блокировки будут сняты после выполнения запроса;
  - использование Read Committed Snapshot (при работе с SQL Server переход на платформу 8.3 без режима совместимости с 8.2). Разделяемые блокировки на уровне СУБД не будут ставиться вовсе;
  - отказ от включения в транзакцию механоизмов, вызывающих непрогнозируемое увеличение ее вермени и ставящих ее в зависимость от посторонних ресурсов (модальные окна, работа с внешними источниками, вложенные транзакции);
  - отказ от ошибочного рекурсивного вызова *ЭтотОбъект.Записать()* из транзакции записи этогоже объекта. Платформа распознает такую ситуацию и не дает развиваться рекурсии, но ошибки блокировок при этом возникать могут;
  - снижение времени транзакции, как за счет оптимизации работы кода, так и за счет объединения нескольких транзакций в одну (например, групповая обработка документов в одной транзакции);
  - повышение производительности оборудования позволяет снизить вероятность взаимоблокировок, при этом однако, не усраняя их причин.


--------------------------------------------------------------------------------------------------------------------------------------
## 3.10. Эскалация блокировок

Эскалация (укрупнение) блокировок - это повышение гранулярности блокировки (lock granularity, в некоторых источниках - lock level, "уровень блокируемых данных"). Это процесс преобразования многих мелкогранулированных блокировок в меньшее число крупногранулированных блокировок при вероятном увеличении конкуренции параллелизма.

Гранулярность - это объем (уровень в иерархии) ресурсов, на который накладывается блокировка. Упрощенно можно считать, что существуют следующие ресурсы, которые могут блокироваться СУБД:
  - строка: используется в управляемом режиме управления блокировками;
  - ключ: блокировка строки в индексе, используемая для защиты диапозонов значений ключа в транзакциях с уровнем изоляции Serializable, используется в автоматическом режиме управления блокировками при работе с регистрами;
  - страница;
  - таблица;
  - база (монопольный режим).
    
Не важно, блокировались данные на уровне записей (строк), на уровне диапазона ключа или на уровне страницы. После эскалации они окажутся заблокированы на уровне таблицы, т. е. эскалация всегда происходит до уровня таблицы.


--------------------------------------------------------------------------------------------------------------------------------------
## 3.13. Сведения об индексах базы. Способ получения этих сведений. Кластерный и некластерные индексы

Подход к получению сведений об индексах может быть таким же, как тот, что мы использовали в предыдущей главе: не имея справочников, с помощью кода получить в отладчике структуру хранения данных:

*ТаблицаСоСтруктурой = ПолучитьСтруктуруХраненияБазыДанных();  
ТаблицаСоСтруктурой.Сортировать("Метаданные, ИмяТаблицыХранения");*


--------------------------------------------------------------------------------------------------------------------------------------
## 3.14. Планы запросов. Получение плана запроса в профайлере SQL. Операторы плана, наиболее важные для нас

План выполнения запроса - это последовательность операций, необбходимых для получения результата СУБД.

Шаги для получения плана запроса:
  1. Запустить SQL Server Profiler
  2. Создать тарссировку, можно использовать стандартный шаблон
  3. В свойствах тарссировки:  
       а. Убедиться, что в нее входят события SQL:BatchStarted, SQL:BatchCompleted, RPC:Completed.   
       б. Установить галочку "все события"  
       в. Добавить события Showplan Statistics Profile и Showplan XML Statistics Profile из узла Performance  
       г. Снять голочку "все события"  
       д. Установить голочку "все столбцы"  
       е. Добавить столбец "DatabaseName"  
       ж. Зайти в "фильтры столблцов", поставить фильтр "DatabaseName" "Похоже на (Like)" <написать_имя_своей_базы>  
       з. Убедиться что у события Showplan Statistics Profile включен столбец BinaryData   
       и. Снять голочку "все столбцы"  
  4. Если запрос выполняется из 1С, в конфигураторе устанить одну точку отсанова на отладчике на строке интересующего нас запроса, и вторую сразу после него. Дойти до первой точки останова.
  5. Запустить трассировку
  6. Позволить приложению выполнить запрос (если он выполняется из 1С), это значит продолжить отладку и дойти до следующего останова на отладчике; если запрос выполняется из SQL Management Studio, это значит запустить его).
  7. Осатановить трассировку в приложении SQL Server Profiler ("Паузой", если нужно, чтобы при следующем выполнении трассировки запроса строки, полученные при нынешной трассировке, оставлись; "Стопом", если нужно, чтобы они очистились)
  8. Найти свой запрос в трассировке. Обычно ориентируются по наибольшему значению в поле Duratin для событий SQL:BatchCompleted или RPC:Completed, потому что есть основани считать, что именно иследуемый запрос имеет наибольшую длительность. События Showplan Statistics Profile и Showplan XML Statistics Profile, относящиеся к иследуемому запросу, находятся непосредственно над ними.
  9. Выбрать событие SQL:BatchStarted, SQL:BatchCompleted или RPC:Completed, посмотреть текст запроса так, как его получает SQL Server
  10. Выбрать событие Showplan Statistics Profile, посмотреть план запроса, обратить внимание на используемые операторы и столбцы Rows (количество строк) и Executes (количество выполнений) для них
  11. Выбрать событие Showplan XML Statistics Profile, посмотреть графический план запроса с помощью подсказки
  12. При не обходимости сохранить трассировку
  13. По совокупности полученных показателей сделать вывод об оптимальности выбранного плана

Дополнительная информация о плане запроса, выводимая в виде всплывающей подсказки.
![Дополнительная информация о плане запроса](https://github.com/grydni4ok/1C/blob/main/%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82/%D0%9D%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0%20%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82%D0%B0/%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/%D0%9F%D0%BE%D0%B4%D1%81%D0%BA%D0%B0%D0%B7%D0%BA%D0%B0%20%D0%BF%D0%BB%D0%B0%D0%BD%D0%B0%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0.png)


**Важные операторы**

**Скинирующие операторы**.

Скинирование - это получение всех записей. Разница состоит в только в том, что именно проходится: кластерный индекс, некластерный индекс или сама таблица. Просмотрев все записи, сканирующие операторы возвращают ту их часть, которая подходит под условие, если оно задано необязательным предикатом WHERE.
![Сканирование таблиц](https://github.com/grydni4ok/1C/blob/main/%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82/%D0%9D%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0%20%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82%D0%B0/%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/%D0%A1%D0%BA%D0%B0%D0%BD%20%D0%BF%D0%BB%D0%B0%D0%BD%D0%B0.png)

Сканирование не приводит к избытоным блокировкам в двух случаях:
  - на самом деле нужна вся таблица;
  - сканируется временная таблица, если посмотреть на объект, будет видно, что она временная  
*Table Scan OBJECT:([tempdb].[dbo].[#tt3] AS [T2]) [T2].[_Q_000_F_000RRef], [T2].[_Q_000_F_001]*

 План запроса может считаться не оптимальным, если в нем встречается оператор сканирования, и при этом:  
   - время выполнения оператора очень большое, как в абсолютном, так и в процентном выражениее (величина  превышающая 20% от общего времени);  
   - количество строк, возвращаемых оператором, несопоставимо меньше количества строк в таблице;  
   - количество строк возвращаемых оператором, может быть не намного меньше количества строк в таблице, но установлено, что конфликты блокировок возникают именно из-за избыточного блокирования не используемых на самом деле строк.

Оператор Constant Scan.  
![Constant Scan](https://github.com/grydni4ok/1C/blob/main/%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82/%D0%9D%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0%20%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82%D0%B0/%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/%D0%9A%D0%BE%D0%BD%D1%82%D1%81%D0%B0%D0%BD%D1%82%20%D0%BF%D0%BB%D0%B0%D0%BD%D0%B0.png)  

**Операторы поиска по индексу**  
Эти операторы первоначально счывают только строки, найденные по индексу с указанным в предикате *SEEK:()* условием поиска. если этого не хватает для полного выполнения условий, может включаться не обязательный предикат *WHERE:()*, в котором подсистема хранилища вычисляет выражение для всех строк, удовлетворяющих предикату *SEEK:()*. Предикат *WHERE:()* уже не исполльзует индекс.  

![Index Seek](https://github.com/grydni4ok/1C/blob/main/%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82/%D0%9D%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0%20%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82%D0%B0/%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA%20%D0%BF%D0%BE%20%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D1%83.png)  

Оператор поиска по индексу может приводить к избыточным блокировкам, если в нем есть необязательный предикат *WHERE:()*, потому что в этом случае все равно блокируются все строки прочитанные по условию предиката *SEEK:()*.  
План запроса может счтаться не оптимальным, если в нем встречается  оператор поиска по индексу, и при этом:  
  - количество строк, возвращаемых оператором по совокупности условий предикатов *SEEK:()* и *WHERE:()*, несопоставимо меньше количества строк, возвращаемых только по условию предиката *SEEK:()*;
  - количество строк, возвращаемых оператором по совокупности условий предикатов *SEEK:()* и *WHERE:()*,может и не намного меньше количества строк возвращаемого только по условию предиката *SEEK:()*, но установлено что конфликты блокировок возникают именно из-за избыточного блокирования избыточных ресурсов.

**Операторы соединения**  

Эти операторы выполняют логические операции соединения результатов выполнения других операторов, так же интрпретируемых как таблицы. Nested Loops и Merge Join.   

![Nested Loops и Merge Join](https://github.com/grydni4ok/1C/blob/main/%D0%AD%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82/%D0%9D%D0%B0%D1%81%D1%82%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0%20%D1%8D%D0%BA%D1%81%D0%BF%D0%B5%D1%80%D1%82%D0%B0/%D0%9A%D0%B0%D1%80%D1%82%D0%B8%D0%BD%D0%BA%D0%B8/%D0%9D%D0%B5%D1%81%D1%82%D0%BE%D0%B4%20%D0%BB%D1%83%D0%BF%D1%81.png)  

Nested Loops - самый простой способ соединения таблиц. Затраты на его выполнене минимальны. Из-за этого оптимизатор SQL Server использует этот оператор всегда, когда не может определить, как именно правильнее соединять таблицы. Это может проиходить просто по ошибке, но обычно причина все таки есть. Такой причиной может быть не актуальная статистика. Чаще всего, однако, это не неактуальная статистика, а ее отсутствие, что всегда имеет место, когда в запросе на языке 1С используеют соединение с вложенными запросами, соединение с виртуальными таблицами, подзапросы в условиях или в условных соединениях.  

Недостаток использования оператора Nested Loops заключается в том, что  при присоединении таблиц запрос к внутренней (ниже расположенной на плане запроса) таблице выполняется столько раз, сколько строк во внешней (выше расположенной). Если речь идет о соединении тблиц, по которым нет статистики, вся работа предоставляется на волю случая, что может прямо являться причиной критической деградации производительности при выполнении таких запросов. 



--------------------------------------------------------------------------------------------------------------------------------------
## 3.16. Работа с SQL Server. Где хранятся временные таблицы. Где хранятся снимки Snapshot для уровня изоляции Read Committed Snapshot

Временный таблицы хранятся в Tempdb. Снимки Snapshot для уровня изоляции Read Committed Snapshot там же.
Tempdb – это служебная база SQL Server.

## 3.17. Работа с SQL Server. Где размещать базы. Как переносить базы

Прежде чем поднимать вопрос о размещении баз, отличающемся от расположения по умолчанию, необходимо понять, для чего это нужно. В работающих продуктивных системах всегда есть возможность понять, чего не хватает:  
  1. если задача не успевает выполниться за отведенное время даже в однопользовательском режиме,  то не хватает скорости собственного диска с накладными расходами на передачу данных до него и с него;
  2. задача не успевает выполниться за отведенное время в многопользовательском режиме - не хватает параллельно работающих дисков; причем речь может идти и про параллельно работающие диски в массиве, и про разные диски под разные базы, и про разнесение базы и журнала транзакций.  

Для баз в тестовых средах, когда конкретика не ясна, гарантированно не ошибочным вариантом мы считаем следующий:
  1. если дают выбирать, мы выбираем RAID 10 (1+0), находящийся в нашем монопольном владении, и размещаем на нем все базы;
  2. Выбираем диски без RAID, если:  
       диски без RAID будут у нас в монопольном владении, а RAID придется делить с кем то еще
       RAID заведомо медленный (5 и 6)
       не понимаем, кто и в какие сроки восстановит информацию средствами RAID
       понимаем, кто восстановит средствами RAID, но видим что восстановление с бекапа быстрее и дешевле
       имеем дело с RAID 0 для чего-то, кроме Tempdb


## 3.18. Работа с SQL Server. Различия между полной (FULL) и простой (SIMPLE) моделями восстановления базы. Особенности сжатия журнала транзакций  

SQL Server поддерживает 3 модели восстановления базы:
  1. полная (FULL). Требует копирования журнала транзакций и обеспечивает возможность этого;
  2. с дополнительным протоколированием (BULK_LOGGED). Не актуально использование в 1С
  3. простая (SIMPLE). Резервных копий журналов транзакций нет, операции по управлению ими не поддерживаются.

Простая подходит для тестовых баз и к ЦУП.

## 3.19. Работа с SQL Server. Настройка и использование бэкапов различных видов

SQL Server позволяет делать резервные копии трех видов:  
  1. полная (full)
  2. разностную (differentail). Храница разница между текущим состянием базы, и ее состоянием на момент полной копии
  3. копию журнала транзакций (не используется и не поддерживается при простой модели восстановления)


--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------























